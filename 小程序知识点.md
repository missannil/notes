## 小程序项目配置文件 project.config.json

1. [文档链接](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)

## 小程序的基本情况

- 小程序的特点

1. 依赖微信
   相比 h5 依赖浏览器，小程序依赖微信
2. 无需适配
   对比原生 App 需要多端开发多个版本程序(安卓端,苹果端等移动端)
3. 社交分享
   支持直接或 App 分享给微信好友和群聊
4. 出色体验
   拥有接近原生 App 的功能(看微信开放多少接口),相比 h5 有优势
5. 用完即走，随手可得
   通过扫码，长按 微信搜索 公众号，好友推荐等方式获取服务，用完即走。而 h5 一般通过搜索网址、导航网站或网址进入。app 需要下载安装
6. 低门槛
   个人就可以注册了。
7. 图片展示
   ![小程序的产品优势](/iamges/小程序的产品优势.png)
   ![小程序的产品优势](/iamges/小程序特点的表现.png)

## hover class

navigator 标签的 hover class 默认 是加透明度 原理是 点击态的时候把 hover class 的样式加入到 class 中去,注意样式的权重，放在后面

## 小程序数据绑定和事件机制

1. webviewId
   在控制台中的 appData type 中 有当前页面的数据信息,可以直接对数据修改做调试。其中**webviewId**是当前 vebview 渲染的进程，这就引出了，小程序 webview 是多线程的，每个页面都是一个独立的线程,wxs 继承在 webView 中 可对样式做修改。那么简单的逻辑事件，改变样式的行为,就可以通过 wxs 来进行，这样避开了，web 层和 js 逻辑层的传输,更加快。
2. 逻辑层都是一个 js 引擎。

## 小程序的状态管理之 mobx

- 安装:
  1. 在小程序 program 文件夹下初始化项目(之前初始化过就跳过) `npm init -y`
  2. 下载 'mobx-miniprogram' 'mobx-miniprogram-bindings'模块
     ```js
       npm i -S mobx-miniprogram mobx-miniprogram-bindings
     ```
  3. 小程序菜单--工具--构建 npm,之后小程序就把 npm 模块加载到自己认识的文件夹下面了,此时你可以删除下载过的模块和 pack.json 了。
- 创建 store

  1. 一般单独创建一个 js 文件作为 store

     ```js
     // store.js
     import { observable, action, toJS, configure } from "mobx-miniprogram";
     // configure({
     //   enforceActions: 'observed' //看mobx文档吧
     // })
     export const store = observable({
       // 数据字段

       numA: [1, 2, 3], //数组变正常数据 const newArr = this.arr.slice()
       numB: { a: 1, b: 2 }, //对象变正常数据 const NewObj = toJS(obj)
       numC: 4,

       // 计算属性
       get sum() {
         return this.numA.slice()[0] + toJS(this.numB).a + this.numC;
       },

       // actions
       update: action(function (data) {
         const arr = this.numA.slice();
         arr.forEach((ele, i) => {
           ele + data[i];
         });
         this.numA = arr;

         const obj = toJS(this.numB);
         //修改obj数据....
         this.numB = obj;
       }),
     });
     ```

- component 组件绑定 store

  ```js
  import { storeBindingsBehavior } from "mobx-miniprogram-bindings";
  import { store } from "../../store/store";

  Component({
    behaviors: [storeBindingsBehavior],
    data: {
      someData: "...",
    },
    storeBindings: {
      store,
      fields: {
        //绑定的数据和data里面的一样用
        numA: () => store.numA,
        numB: (store) => store.numB,
        sum: "sum",
      },
      actions: {
        buttonTap: "update",
      },
    },
    methods: {
      myMethod() {
        this.buttonTap(data); //触发store的updata事件
        this.updateStoreBindings(); //页面立即同步store的数据，不然会在下一次wx.nextTick才同步
      },
    },
  });
  ```

- 在 Page 构造器中使用

  ```js
  import { createStoreBindings } from "mobx-miniprogram-bindings";
  import { store } from "../../store/store";

  Page({
    data: {
      someData: "...",
    },
    onLoad() {
      this.storeBindings = createStoreBindings(this, {
        store,
        fields: ["numA"], //绑定的数据和data里面的一样用
        actions: ["update"],
      });
    },
    onUnload() {
      this.storeBindings.destroyStoreBindings(); //离开页面要解绑，不然内存溢出
    },
    myMethod() {
      this.updata(data); //触发
      this.storeBindings.updateStoreBindings(); //store返回的同步setData会在下一次wx.nextTick才更新，这个是立即更新
    },
  });
  ```

- 注意的事情 在 store 文件中 直接使用 store.xxx 就可以对属性赋值。
  在 app.js 中，因为没有 this.setData()函数，所以可以绑定 store，但是不可以绑定字段，就是说些了 fields 字段会报错，但是可通过绑定的 store 那数据,和 action 触发函数

## 云函数本地调试

以往都是上传本地云函数到云端后，运行小程序触发云函数，看云端函数 log 日志等方法，来调试函数
反复修改，上传 很不爽；
在函数右键开启云本地调试，就不用上传了，每次小程序调用的时候，会直接调用到本地函数，无需再云端看 log 日志，在本地就可以
断点等调试。可以了，在上传云函数，关闭本地调试。就这么个意思.

可以通过小程序客户端触发，就是重新编译。这样很慢。

快速方法是通过手动模拟触发云函数，点击右下角调用就可以触发函数，并传个 json 相当于 event 那个意思。这样反应都快。

## 文件缓存

1. 先上传图片到云储存,
2. 启动时候，检查缓存有没有图片缓存路径，有拿出来，给页面分发，页面通过变量给 image 的 src
   如果没有本地缓存，就下载图片，然后把下载的缓存路径缓存到数据缓存，图片下载来会自动缓存到本地 tmp 下，属于文件缓存，不是数据缓存，数据缓存记录的是文件缓存的地址；

## 云函数返回的 await 中的 data 是值 小程序端返回的是 result 值

小程序端调用的时候返回的 reslut 里面是云函数返回的值，所以要 result.data
如果想直接拿到 data 值，那么在云函数 await 后加.data 这样就直接把值返回给小程序端的 result 了 小程序端就直接 result 就是值了

## utc 协调世界时间 和 gmt 格林威治时间

云端的时间有 2 个函数 一个 new Date() 一个 db.serverDate() 显示都是 gmt 格式 和客户端 js 一样，但是返回给客户端后，就变成了 utc 格式，所以还是用 new Date().getTime()变为数字吧，好比较！

## 云函数的调用

1. 小程序端调用前记得先初始化 `wx.cloud.init({env:"test_123",traceUser:false})` env 默认 default traceUser 默认 true

2. 创建云函数后, 要安装 wx-servers-sdk 依赖用于云函数调用, 自行安装 `npm install --save wx-server-sdk@latest`
   或 `npm i ` (因为已经有初始化过的 pack.json 文件了，里面有依赖记录了) 注意，通过云端安装依赖可能出错的.建议安装后再上传
3. 云函数端即是管理端,可以随意调用数据库和存储,也一样需要初始化和引用依赖,```cloud.init() env 默认 或者输入看到的，或者通过 sdk 的
   变量, 都可以。
4. ```js 如 db.collection(name).doc(_id).get()
           获取不到集合时候正常情况下会报错，像下面这样初始化数据库就不会了 返回为 null
       const db = cloud.database({
         throwOnNotFound: false
       })

   ```

5. 云函数 以下设置将 doc.get 的行为改为：如果获取不到记录，不抛出异常，而是返回空。
   ```js
   cloud.init({
     env: cloud.DYNAMIC_CURRENT_ENV,
     throwOnNotFound: false,
   });
   ```
   当然也可以在初始化 db 时候设置
   ```js
   const db = cloud.database({ throwOnNotFound: false });
   ```

## 小程序 Api promisify

- 初始化 npm 项目 在 miniprogram 文件下 `npm init -y`
- 再 `npm install --save miniprogram-api-promise`
- 开发者工具下构建 npm,然后目录里面会出现模块数据了，
  在 app.js 开头调用如下

  ```js
  import { promisifyAll, promisify } from "miniprogram-api-promise";
  const wxp = {};

  promisifyAll(wx, wxp); // promisify all wx's api

  wxp.getSystemInfo({
    success(res) {
      console.log(res);
    },
  }); // compatible usage

  promisify(wx.getSystemInfo)().then(console.log); // promisify single api
  ```

      lifetimes: {

  attached: function () {},
  moved: function () {},
  detached: function () {},
  },

## computed 和 watch 和 observers 还有 observer

1. computed 和 watch
   要引入 miniprogram-computed 依赖(dependence)
   必须在 Component 下的时候，不能使用 this，第一个参数是 data

   ```js
   const behaviorComputed = require('miniprogram-computed')
   Component({
      behavior:[behaviorComputed]
      data:{
        a:1,
        b:2，
        c:3
        _a:1
      }
      computed:{
        sum(data){
          return data.a + data.b
        }
      },
      watch:{//监控的数据用字符串和逗号分开，
        'a,obj.key'(a,key){ //参数按监控的顺序取参数 a b 变化才触发 不支持通配符*(不懂)
          this.setData({
            c:a + b
          })
        }
      },
      observers:{// a b a和b发生this.setData动作就触发，不管值变化不变化 ， 由于历史原因 怕老版本自定义方法有这个关键字，所以page页下面不支持这个属性，可以把page当组件 用 Components({})来取代Page({})可以加监控一个辅助值作为old数据来比对，相同就return不进行
        'a,b,_a'(a,_a){ //
        if(a == _a){
          return
        }
          this.setData({
            sum:a + b
          })
        }
      }
      }),
   ```

## 小程序购物车

1. 小程序全局有 tempCart 对象，为登录状态，加入此购物车，当登录后，会把 tempCart 加入到 userInfo 里面的 cart，

##微信小程序的登录

1. 云开发模式登录
   在 app.js 里面先通过 wx.getSetting 看 authSetting['scope.userInfo']有没有授权，if 授了,读取当地用户信息，wx.getStorage('userInfo'),本地有值就赋值给 globalData 并 hasUserinfo 为 true，没有就调取 login 函数 去登录并赋值给 globalData 和本地 wx.setStorage({key:'',data:''}),如果没有授权，就等用户调取登录页面点击登录按钮再发起 login 和本地存储；
   登录状态里面，除了有基本用户信息外（userInfo 和 openId）还有订单和购物车，收藏，行为（浏览过哪些，停留几秒，

```js
wxp.getSetting().then((res) => {
  res.authSetting["scope.userInfo"];
});
```

## project.config.js 的配置

这是小程序的项目配置文件，在小程序 加载，编辑 预览 上传小程序时，会按次配置文件，执行相应的配置，比如在加载时候，

## 差值表达式作为作为对象 key 时候 用[]可以 比如 boj[xxx] 其中 xxx 相当于{{xxx}}

## 分包/独立分包/预下载

1. 为什么要分包：分包后页面首先加载主包并展示，当进入跳转到分包页面时候，才会下载分包页面，如果我们把首页未展示的内容放入其他分包（页面）中去，通过预下载的方式去加载，达到首页快速展示的目的；也能拓展小程序大小 已经 12 了，可以有 6 的分包了
2. 分包由配置文件决定:在 app.json 里面 pages 项写主包页面，其他页面写在 subpackage 下面，例如:
   ```json app.json文件
      "pages":[
        "mainPackage/home/home"
        //这里写首页路径，尽量少页面，加速首页展示，分页写下面subpackage里面
      ],
      "subpackage":[
         //分包路径 每个里面root是根目录，name是另命名，pages是包含页面路径
        {
          "root":"packageA",
          "name":"category",
          "pages":[
            "home/home",
            "index/index"
          ]
        },
        //上面是一个分包，下面是另一个分包
        {
          "root":"packageB",
          "name":"cart",
          "pages":[
            "home/home",
            "index/index"
          ],
          "independent": true  //加入此项为独立分包 可单独加载，详见独立分包
        }
      ]
   ```
3. 预加载每个页面可以预加载 2m 的页面内容，可以是不同分包里的页面，比如我运行首页的时候项，加载分包 A 里面的 x 页面和分包 B 里面的 y 页面，如下写法:

```json app.json文件
     "preloadRule":{
        "mainPackage/home/home":{
          //当进入此路径页面的时候进行预下载pages里面的分包页面
            "work":"all",//不写默认工作在wifi下写了all数据下也加载；
            "pages":["packageA","cart","__App__"]
            //这里写了2个分包，一共不能超过2m，编译是会计算，多了报错，值写路径，name都可以，主页可以用__APP__来代替；
        }
     }
```

4. 独立分包：独立分包不依赖其他资源，启动时（从搜索进入）不会下载主包及其他分包既可独立运行，提高速度。而非独立分包进入时，一定会先下载主包和所在分包，才会展示；在 app.json
   里面的 subpackage 里面的分包项中加入 independent:true 例如 上面的分包

- 独立分包中不能依赖主包和其他分包中的内容，包括 js 文件、template、wxss、自定义组件、插件等。
- 主包中的 app.wxss 对独立分包无效，应避免在独立分包页面中使用 app.wxss 中的样式；
- App 只能在主包内定义，独立分包中不能定义 App，会造成无法预期的行为；
- 独立分包中暂时不支持使用插件。

## 场景值的获取

1. wx.getLaunchOptionsSync().scene
2. 在 onlaunch 或 onshow 的时间函数中调用

```js
Page({
  data: {},
  onlaunch(e) {
    console.log("当前场景值是: " + e.scene);
    console.log("当前场景值是: " + wx.getLaunchOptionsSync().scene);
  },
});
```

## 模板的使用

1. ### 模板定义
   可定义在页面中，也可以定义在单独.wxml 中，单独文件需要 import 引入，可以传值
   ```html
   <template name="test">
     <view> 姓名:{{name}} 年龄:{{age}} </view>
   </template>
   ```
2. ### 引入和调用

   引入模板需要把 import 标签写在页首，可引入多个，具体调用时根据 is 值来选择模板
   模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 <wxs /> 模块。

   ```html
       <!-- 外部单独nage模板 /template/name.wxml -->
           <template name="name">
             <view>
                     姓名:{{name}}

             </view>
           </template>
       <!-- 外部单独age模板 /template/age.wxml" -->
           <template name="age">
             <view>
                     年龄:{{age}}
             </view>
           </template>

       <!-- 引入页wxml -->

         <import src="/template/name.wxml"/> 引入模板 可以不写最后的wxml
         <import src="/template/age.wxml"/>
         <view class="container>
             <template is = "name" data="{{...test_data}}"/>  通过is值来选择模板
             <block wx:for="{{[1, 2, 3, 4, 5]}}">
                 <template is="{{item % 2 == 0 ? 'name' : 'age'}}" data="...test_data"/>
             </block>
         </view>
       <!-- 引入页js部分 -->
           page({
             data:{
               test_data:{
                 name:'zhao',
                 age:19
               }
             }
           })


   ```

   ```html
   <template
     name="aaa"
     data="{{LocationName,openType:'navigate',url:'/pages/mainPackage/location/location'}}"
   />
   传值时，data里面是键值对，内部获取值写data里的键，如果是js动态值就写一个
   ```

3. ### 模板的样式
   模板的样式可以在模板.wxml 同级目录书写，通过在 app.wxss 中 @import "src"全局引入，这样可以避免在每一个需要模板的地方都引入模板 wxss 文件。也可通过样式库的方式作用于模板样式

## wxs 语法

为了监控 小程序的视图层和逻辑层是分开渲染的，相互独立的线程 可以在文档内看到小程序逻辑图
在 2.44 版本前，视图层渲染需要先把事件传递给逻辑层，在逻辑层处理数据后返回给视图层渲染，这样低效率
现在应该在样式

- 代码写在 wxml 中的 wxs 标签或单独的一个.wxs 文件
  代码中 对外接口用 module.exports = {} /可以没有对外接口
  模块中作用域私有。
- 在.wxs 模块中引用其他 wxs 文件模块，可以使用 require 函数。
  引用的时候，要注意如下几点

1. 只能引用 .wxs 文件模块，且必须使用相对路径。
2. wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面， 多个地方，多次引用，使用的都是同一个 wxs 模块对象。
3. 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。
4. wxml 文件中的数据 会以引入的 wxs 文件 module 为先 引用位置

```js
//.wxs文件
var tools = require("./tools.wxs");

console.log(tools.FOO);
console.log(tools.bar("logic.wxs"));
console.log(tools.msg);
```

5. wxs 调用逻辑层 用 callMethod 逻辑层调用 wxs 用 change:prop = {{wxs.aaa}} prop="{{逻辑层的变量xxx}}" 当逻辑层改动 xxx 这个变量 wxs 中因为 change:prop 的存在，就会调用 wxs.aaa
6. wxs 事件参数对象(event,ownInstance)

```js
//一参数   (JSON.stringify(event))
event = {
  type: "scroll",
  timeStamp: 16091,
  target: {
    id: "",
    offsetLeft: 0,
    offsetTop: 60,
    dataset: {},
  },
  currentTarget: {
    id: "",
    offsetLeft: 0,
    offsetTop: 60,
    dataset: {},
  },
  mark: {},
  detail: {
    scrollLeft: 0,
    scrollTop: 1,
    scrollHeight: 870,
    scrollWidth: 375,
    deltaX: 0,
    deltaY: -1,
  },
  mut: false,
  instance: {
    selectAllComponents: null,
    selectComponent: null,
    removeClass: null,
    addClass: null,
    hasClass: null,
    setStyle: null,
    getDataset: null,
    getState: null,
    triggerEvent: null,
    callMethod: null,
    requestAnimationFrame: null,
    getComputedStyle: null,
    animate: null,
    clearAnimation: null,
  },
};
// 二参数 (JSON.stringify(ownInstance))
ownInstance = {
  selectAllComponents: null,
  selectComponent: null,
  removeClass: null,
  addClass: null,
  hasClass: null,
  setStyle: null,
  getDataset: null,
  getState: null,
  triggerEvent: null,
  callMethod: null,
  requestAnimationFrame: null,
  getComputedStyle: null,
  animate: null,
  clearAnimation: null,
};
```

## 自定义组件的使用

组件和页面结构是一样的，其实就是为了提高代码复用性，整洁性，
同样的 4 个文件，json wxml wxss js
同 template 的区别呢，就是 template 只能展示结构样式(样式定义在全局 app.wxss)，组件可以有自己的样式和逻辑,那么 template 和 wxs 一起用呢，而且相比 js，wxs 主要是做小功能，比如好比 filter，或者 computed 这样的简单逻辑。

1. ### 组件的创建
   利用小程序右键可快速创建 components 组件
   在 components 文件夹下建立一个 test 文件夹，下面建立 4 个文件，在 wxml 里写结构
   在 json 里面标出自己是组件才能被调用 "component":"true"
   如果还需要引入其他组件 就在"usingComponents":{
   "other":"相对路径"
   }
2. ### 样式的引入

1) app.wxss 是全局样式，用于作用所有页面。
1) 页面自己的 wxss 默认只作用自己,默认和页面中的自定义组件隔离
1) 在所有的 wxss 里面写样式要注意尽量使用类选择器，避免 id。
1) app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。
1) 自定义组件默认与外界 wxss 隔离。
   要使用外部样式 有几种方法

- json 中写 styleIsolation: apply-shared
- js 中写 styleIsolation: apply-shared
- js 中写 options:{addGlobalClass:true}

3. 数据绑定

1)  先找 properties 再找 data
2)  properties 是接收外部的行间属性值，供内部只用，data 就是内部定义值
3)  和 vue 差不多，properties 也有对象的写法(vue 数组写法)

    ```js
      properties{
              name:{
                  type:'String',
                  value:'zhao',//默认值
                  observer:function(newValue,oldValue){//推荐外部Component下面的observers来监控数据变化
                    console.log(newValue,oldValue)
                  }
              }
      }
    ```

4. 组件间数据传递
   1）父传子 用属性名 observers 监控
   自定义组件上属性的动态值，来自与所在的 page/组件上的 data，如果组件 js 的 properties 里注册了这个属性，那么组件优先 properties 里面的属性值，如果没有再去找自身 data 定义的属性值；
   外部属性值变化，组件内会随之改变，但是组件内通过 setData 改变值，外部不会随之改变，就是说，只能外部影响内部，内部无法影响外部;
   2） 子传父 事件方式
   页面中的组件属性上绑定好事件```bind:my_event 或者不要冒号 bindmy_event 都可以
   那么在组件的 js 上就可以通过调用 this.triggerEvent('my_event',eventDetail 对象,options 对象)来触发事件,eventDtail 对象用来传值，options 对象配置是否可以 bubbles 冒泡
   composed（事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部）capturePhase 是否捕获

5. 组件的生命周期

   ```js

      lifetimes: {
        created:function(){
          //组件建立完成还没有attached挂载之前执行  attached好比mount（vue）
        }
        attached: function() {
          // 在组件实例进入页面节点树时执行
        },
        detached: function() {
          // 在组件实例被从页面节点树移除时执行
        },
        pageLifetimes: {
        show: function() {
          // 页面被展示
        },
        hide: function() {
          // 页面被隐藏
        },
        resize: function(size) {
          // 页面尺寸变化
        }
    }
   ```

6. 组件的 behaviors 属性 是用来引入公共代码的，里面也有属性，数据，方法，生命周期
   behaviors 数组里定义了 引入的 behavior,可以多个，多个的数据重复，后面会覆盖前面，是对象会合并，方法也是后面覆盖前面，生命周期是调用一次，

   ```js
   // my-component.js
   var myBehavior = require("my-behavior");
   Component({
     behaviors: [myBehavior],
     properties: {
       myProperty: {
         type: String,
       },
     },
     data: {
       myData: {},
     },
     attached: function () {},
     methods: {
       myMethod: function () {},
     },
   });
   ```

7. 监控器属性 类似(计算属性的实现)
   监控属性 A 和 B 变化就设置 sum 变化，A 和 B 作为参数，this.setData 时无需 加 this.data

```js
      observers: {
      'A,B': function (A, B) {
        this.setData({
          sum: A + B
        })
      }
    },


```

8. 纯数据模式(pureDataPattern) 使用如下

   ```js
   Component({
     options: {
       pureDataPattern: /^_/,
     },
     properties: {
       a: Boolean,
       _b: {
         type: Boolean,
         observer() {
           // 不要这样做！这个 observer 永远不会被触发
         },
       },
     },
   });
   ```

## 双向数据绑定 model:

小程序 2.12.0 里面开始支持 "model:" 语法糖
主要作用自认为是把页面和组件之间的关联数据进行绑定 就是说页面和组件内部公用一个数据，不管那边对数据做了更改都同步更改，之前是由页面向组件单方便数据同步，组件通过 this.triggerEvent 传递组件数据给页面函数来完成的；
新的语法糖好比 在组件 properties 创建时，看到 model:xxx 的属性会自动建立一个 triggerEvent，页面创建时候会多一个事件函数用于呼应组件内部 trigger 事件

```js
     //过去
     <custom-component property="{{value}}" bind:handle="change"/>
     // 组件被传递一个property数据值为value 当组件内部改变value值的时候，会triggerEvent外部的handle事件 页面中 的change事件接受到组件内部的trigger和参数后，setDate页面中的value
     //现在
      <custom-component modle:property="{{value}}" />
      // 只要在属性前面加一个语法糖modle就可以了，内部value值改变时候，会自动外部页面的value值,小程序内部集成了组件内部的trigger和外部的setData事件

```

## 自定义组件思路

- ### 自定义 tabbar

1. 原生导航栏是通过在 app.json 中配置文件构建的
   ```js
      tabbar:{
        color:,
        selectedColor:'#123456',
        background:'ffffff',
        position:'top/bottom'，
        borderStyle:'black'
        list:[{},{},{}]
      }
   ```
2.

- ### 自定义导航栏 navigationbar

1. 原生在 app.json 里 window 项设置属性
   navigationBarTitleText: 文字
   navigationBarTextStyle: 文字颜色
   navigationBarBackgroundColor:背景颜色
2. 自定义需要先取消原生 需要设置属性` navigationStyle:custom`
   原生状态栏和胶囊 是系统 page 固定加载定位在顶部的，
   所以要注意你的自定义状态栏起始位置是和他们重叠的，要不 margin 要不 padding 要不 top
   需要预留他们的位置，状态栏可以通过 wx.getSystemInfo({})异步回调函数取得它的高度信息，let capsule = wx.getMenuButtonBoundingClientRect();来取得胶囊的属性
   计算后 就可以得知，如何保持内容和胶囊平行
3. 自定义组件主要通过外部属性传值，内部 properties 接收值并在组件背部加载为 calss，wx:if 等方法，改变组件内部样式，外部当然也可以通过 slot 来对内部结构进行调整，
   内部在 js 中设置 option:{addGlobalClass 和 multipleSlots }来引入外部样式和多 solt
4. 组件布局多用 flex 和 grid 方式，也可由外部传入
5. 组件的加载形式 单独形式和统一加载 class 形式，单一形式加载好处是用什么加载什么，只需要记住当前组件的传值属性方法，问题是 style 会有重叠，小项目，组件较少推荐使用，
   多组件大项目推荐把所有的 class 写在外部统一加载，可以去重代码。组件库和样式库

## 小程序原生标签

1. <icon type="success|warn" /> 原生用法
   <i class="iconfont icon-weizhi" />
2. 表现可以瞎写但是不带任何样式默认行盒，不要这样用
3. header 和 footer 用 view class="hd|bd|fd|"代替

## slot 插槽

     是用来解决：调用自定义组件的页面想在自定义组件内添加一个组件，哪就用slot
     比如 自定义组件中有A 和 B 组件构成，外部页面想调用自定义组件，并在中间加上一部分结构，那么就可以在自定义组件里面的A前面加个slot name="top",在A和B中间加一个slot name="middle",在B组件后面加一个slot name="bottom"，这样外部在调用自定义组件的时候，根据需要就可以通过 slot='top'或slot='middle'或slot='bottom'来添加想要的结构

1. 单插槽
   在组件中结构中写入 <slot/> 在引入的页面中组件内容即会插入到<slot/>标记位置
   例如:

   ```html 组件
   <!--组件 test.wxml-->
   <view>
     <view> 下面是部分是内容由引入页面决定</view>
     <slot />
   </view>
   ```

   ```html
   <!--引入组件的页面-->
   <view class="container">
     <test> 这里显示的内容是组件外部通过slot插入的 </test>
   </view>
   ```

2. 多 slot 引入 需要在组件的 js 中 写上 options:{multipleSlots:true}

例子：

    ```html test组件
    <!--组件 test.wxml-->
      <view >
            <slot name='top'/>
          <view> 我是中间，上下分别是2个slot <slot/> </view>
            <slot name='bottom'/>
      </view>

````
```js test组件
   component({
       options:{multipleSlots:true}
   })

````

```html
<test>
  <view>我的标签上没有slot name 所以我就去没有名字的slot咯</view>
  <view slot="top">这里是slot属性name为top的插槽内容</view>
  <view slot="bottom">这里是slot属性name为bottom的插槽内容</view>
</test>
```

vue 的 slot 是 在组件里和小程序一样 在引入页面 用 template #name 来做的

## 抽象节点 (generic 通用类 )

页面想调用一个自定义组件 A，自定组件 A 是由 组件 b 和 c 组成的，但是有时候，我想调用一个自定义组件是 c 和 d 的组合，

1. 需要在组件 json 中定义
   ```json
   "componentGenerics": {
   "custom-name": true
   }
   ```
   ```html test组件
   <view class="test" bindtap="func">
     我是内容
     <custom-name />
   </view>
   ```
2. 引用的时候 在组件标签属性里注明 节点属于哪个组件

```html
<test generic:custom-name="input">
  <!-- input也可以是components里面引入的组件 -->
</test>
```

## 引入字体文件

1. 使用https://www.iconfont.cn/阿里巴巴字体库
2. git 注册后，选中 icon 文件加入购物车，添加到自己建立的项目，在项目中生成 font-class 文件（//at.alicdn.com/t/font_1441225_vpmldc5w1z.css）下载文件，改后缀为 wxss，放到 style 或者 icon 下准备使用.
   解释下里面的文件内容：

```css
@font-face {
  font-family: "iconfont"; /* 字体家族名称 */
  src: url("iconfont.eot?t=1575275905318"); /* 兼容IE9 第一个url找不到就会接下去找 url()里可以写网络地址，也可以写自定义64格式的字体文件，我们用的实际是自定义的64进制的字体文件格式*/
  src: url("iconfont.eot?t=1575275905318#iefix") format("embedded-opentype"), /* IE6-IE8 */
      url("data:application/x-font-woff2;xx......xx") format("woff2"),
    url("iconfont.woff?t=1575275905318") format("woff"), url("iconfont.ttf?t=1575275905318")
      format("truetype"),
    /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
      url("iconfont.svg?t=1575275905318#iconfont") format("svg"); /* iOS 4.1- */
  /* 上面文件中，format是让小程序知道字体格式，url里写的都是当地字体文件，只有URl(data:application...)里面写的是我们用的class字体，只需要保留它就可以，日后更新时候，把下载的文件里面的这个数据覆盖之前的就可以了，还需要把增加的类样式也复制进来*/
}
.iconfont {
  /* 统一的样式，在class里面必须要写*/
  font-family: "iconfont" !important;
  font-size: 16px;
  font-style: normal;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.icon-weizhi:before {
  /* 引入哪个icon就在class里面加入 此类，以下相同*/
  content: "\e64b";
}

.icon-icon-test:before {
  content: "\e65b";
}

.icon-icon-test1:before {
  content: "\e65c";
}

.icon-icon-test2:before {
  content: "\e65d";
}

.icon-icon-test3:before {
  content: "\e65e";
}

.icon-arrowRight:before {
  content: "\e60f";
}
```

3. 在 app.wxss 里面引用 @import "/style/iconfont.wxss" 就可以了
4. 调用使用 class 名
   例如

   ```html
   <i class="iconfont icon-weizhi"> <i class="iconfont icon-arrowRight" /></i>
   ```

## sitemap 提示

sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 project.config.json 的 setting 中配置字段 checkSiteMap 为 false

## 小程序构建 npm 时，更改了，会根据 dependencies 里面的内容来构建，如果只是开发中用，不写 dependencies(-S)里面 ，写 devDependencies 里面（-D)也可以被使用但不会被构建。

## 引入@vant/weapp

1.  文件名不能大写的 npm init -y 名字通不过
2.  在小程序 miniprogram 目录下 npm init -y
3.  初始化后，npm install @vant/weapp -S --production
4.  小程序中工-->构建 npm
5.  构建成功后，加入基本样式和 wxs mixins 在 common 文件夹下面
6.  如果构建成功了，可以删除 package.json 和 下载的 modules 包

## @vant/weapp 的使用

### van-icon

## page_hd 的 css 样式注意

1. 内容是 一个 icon，一个当前位置的 navigator 一个 navigator 包裹的搜索框,这里的搜索框作为图片存在，跳转用，css 注意的是，icon 默认行盒，navigator 默认是块盒，把 hd 设置为 flex 后，他们会在一行，但是，如果 hd 没有设置高度，高度会被第三个 navigator 撑开，那么第二个 navigator 要想居中，就需要设置 margin:auto,
   第三个元素想占据后面空间，需要 flex-grow：1；

## 地图 map 组件使用

- map 的各个属性
  1.  show-location 这个属性是在地图显示你当前位置为一个绿色小点，带方向箭头
  2.  坑啊，wx.getLocation（{}）里面的 type 用 wgs84 得到的和 gcj02 得到的不一样啊
      会导致 show-location 小绿点和 getLocation 得到的定位不是一个位置，就是中心不在一起；
      如果默认使用腾讯地图，需要 gcj02 模式，别的还没测试！工具定位用 ip 所以不准的。在真机可以看到是准的，不需要开 gps，不用开数据,wifi 也可以。
  3.  制定商家坐标 logo

## 组件需要知道的事情

- ### button
  1.  open-type 属性值

## 获取用户授权逻辑

从 19 年 1 月 14 日起，设置里默认没有授权选项，只会显示已经授权询问过的选项状态，所以不可以先通过 open-type="openSetting"/wx.openSetting()，再调用接口，而是应该通过调用接口(未授权会弹窗)弹窗的形式获得授权（只能如此了）。

## 关于小程序中使用的单位 rem px（pt） rpx（rpt） 好比 h5 的 rem 适配

rpx 会更加手机 dpi 自动转换为手机的 px 大小 再转换为 pt 大小进行渲染 好比 h5 中的 rem 适配.
为了适配，写 rpx rpx 是相对单位也叫动态单位，设计原型标准是 750rpx \* 1334rpx 所以用 iphone6 做视图标准展示效果正好。比如在 iphone6 上面 width 写的是 750rpx 那么在真机上 小程序会先把 750 按当前真机比例(iphone 5 1rpx = 0.42px)转变为 px 再去渲染视图，从而达到适配所有机型(所有机型都有 rpx 转 px 的比例)。
在小程序中，适配尺寸的做法，上方导航栏 需要让出状态栏高度并和胶囊对齐，通过 wx.getSystemInfo 信息可以得到真机状态栏高度，在通过 getMenuButtonBoundingClientRect()得到胶囊的信息，计算出自定义导航栏的高度，下方自定义 tabbar 的高度固定为 100rpx 实际做法是，tabbar 组件内部尺寸为 height=98rpx + border-top=2rpx 来达到 100rpx 的高度
这样就有了上面和下面的高度 中间高度等于 wx.getSystemInfo 中的 screenHeight - 上部 px -下部 100rpx;
iphone x 之后有了下方的 home 条，适配是这样做的，上部还是一样的，下面通过 padding-bottom:constant(safe-area-insert-bottom)兼容 11.2 之前 iphone
padding-bottom:env(safe-area-insert-bottom)兼容 11.2 之后的 iphone，
中间部分 再减去 constant(safe-area-insert-bottom)或 env(safe-area-insert-bottom)就可以了，完美了！！！！！！！！！！！！！！！！！！！！！！！！！！！
em 和 rem em 是相对当前元素的 font-size 而 rem 是相当与 root 根目录 font-size 来的。
例子
`html html是根目录 谷歌浏览器默认字体为16px <div class="wrapper" style="font-size:30px"> 他的字体是30px <div style="font-size:2em"> 他的字体是60 px <div style="font-size:2em "> 他的字体是120px <div style="font-size:2rem" />t他的字体是32px </div> </div> </div> `

## line-height 的单位 1 1em 100%

1. 1em 等于 100%是值(乘以自身字体大小)，子元素继承（即子元素没有写 line-height 项)值，与子元素 font-size 无关
2. 写的是 1 是倍数，子元素继承需要与自己的 font-size 相乘才是自己的 line-height;

## css var

定义的变量应该在外层，内部可以使用外部的变量（向上 找）最外层就是:root 或者 html :root 除了比 html 选择层级高，别的一样，看习惯，小程序没有 body 只有 page 那就写跑 page 里面咯，例如
page{
--defaultColor:#123456;
--defaultSize:32rpx;
}
如上所写，页面中的下级标签都可以使用上面的变量；
var 的后面还可以跟一个备用属性，例如 color:var(--color,blue)，这时说当--color 找不到的时候，用 blue 代替。

如果想跟两个变量怎么办？var(--color,var(--color1,blue))。注意不能写成 var(--color,--color1,blue)。

如果变量存在，但是格式不对是不会用备用的。例如--color:10px，这样只会导致没有效果，但是不会用后面的备用属性。

## css env()

和 var 差不多，是因为苹果 10（iphone x）以后浏览器提出的 env() 因为屏幕在 iphone 之后出现了圆角地带，和系统菜单等占据的地区，为了使页面显示区域不遮挡系统菜单和不被圆角区域影响，所以 ios 系统出现了系统环境变量来规定安全区域 safe-area 这是系统自带的，css 可以直接引用这个变量，通过 env()函数来获取变量的值，例如

```css constant 和env 分界线是ios11.2 所以要兼容
page{
padding                : 10px;
height                 : 62px;
padding-bottom         : calc(constant(safe-area-inset-bottom) + 10px);
padding-bottom         : calc(env(safe-area-inset-bottom) + 10px);
height                 : calc(constant(safe-area-inset-bottom) + 62px);
height                 : calc(env(safe-area-inset-bottom) + 62px);



/*默认padding*/
padding-bottom: 0;
/*iOS < 11.2*/
padding-bottom: constant(safe-area-inset-bottom);
/*iOS 11.2 >*/
padding-bottom: env(safe-area-inset-bottom);
}
具体写法
@supports (constant(safe-area-inset-bottom)){
    .footer{
        padding-bottom: constant(safe-area-inset-bottom);
    }
}
@supports (env(safe-area-inset-bottom)){
    .footer{
        padding-bottom: env(safe-area-inset-bottom);
    }
}

与calc合用：
padding-top: 10px;
padding-top: calc(10px + constant(safe-area-inset-top));
padding-top: calc(10px + env(safe-area-inset-top));
```

所以小程序在苹果上的页面兼容 可以在 wx.getSystemInfo 获得或者在 wxss 里面引用 env()
感觉上 env()好一些吧，直接获值，直接用吧

## require 和 import 区别

import 和 require 的区别
node 编程中最重要的思想就是模块化，import 和 require 都是被模块化所使用。

遵循规范
require 是 AMD 规范引入方式
import 是 es6 的一个语法标准，如果要兼容浏览器的话必须转化成 es5 的语法

调用时间
require 是运行时调用，所以 require 理论上可以运用在代码的任何地方
import 是编译时调用，所以必须放在文件开头

本质
require 是赋值过程，其实 require 的结果就是对象、数字、字符串、函数等，再把 require 的结果赋值给某个变量
import 是解构过程，但是目前所有的引擎都还没有实现 import，我们在 node 中使用 babel 支持 ES6，也仅仅是将 ES6 转码为 ES5 再执行，import 语法会被转码为 require

小程序中 import 引入的路径 会先在 miniprogram_npm 下寻找，找不到再根据相对路径查找 ../上级 不写或者/或者./ 都是当前目录下 后面可以不写 js

```js
//输出 es6模块
export default function test() {
  console.log("es6");
}
//  引入  es6模块
import test from "../../test";
//输出  nodejs

module.exports = function () {
  console.log("commonJs");
};
//引入 nodejs
const test = require("../../test");
```

因为 小程序运行时候，babel 会把 所有引入都转成 nodejs 规范 commonJs，所以...
无所谓了，喜欢写哪种都可以，es6 的 export 是解构，解析即执行，必须写在页面首位，nodejs 是赋值，调用时赋值，写调用前面就可以了;

## 位置页逻辑

- 默认页面 上面是地图 加载商家为中心点，右下角有我的位置和商家位置点击按钮，下面是标记周围最近配送 markers 点击可以把名字传送到首页 替换当前位置
- onload

1.  加载 markers 配置数组到 data 下。默认中心点是商家
2.  运行 nearMarkers 函数得到数组并加载，显示页面
3.  询问 调用 wx.getLocation() 如果之前没有权限，会弹出对话框，按确定走 success,设置定位点为中心点，加载最近配送点，按拒绝走 fail

### flex 布局应对小程序

小程序整体布局有很多需要注意的地方，如果各个区域用 rpx 写死的化，上方状态栏的高度 和胶囊的高度不确定以及下方的 tabbar 受苹果 home 条的影响所导致的不确定 会影响整体布局。
第一种方法，用 wx.getSystemInfo()来获取 px 值来固定上方 nav 导航栏的位置高度，下方用苹果环境变量 constant(safe-area-insert-bottom) env(safe-area-insert-bottom)来应对，中间部分需要计算 height="calc(100% - 上面 - 下面)" 兼容 height:"calc(100% - 上面 - 下面 - constent(safe-area-insert-bottom)"兼容 :height:"calc(100% - 上面 - 下面 - env(safe-area-insert-bottom)"
还有一种方法是利用 flex 的 flex:1 和 hidden 来解决。就是整体是 flex 布局，中间自动 flex:1,这样中间部分的 height 就会自动大小了，可是这个高度不是固定的，他实际是中间区域最小的高度，中间区域在这个范围内不收影响，当中间内容大于这个高度就会被撑满，但是如果加上 overflow：hidden 就会固定这个高度了，内部可以用 100%来得到这个高度了，为什么不能用 flex:auto 而是 flex:1 呢，就是因为 flex:1 的 flex-basis 是 0 计算出来是 0 + 剩余大小 在 overflow hidden 而 atuo 是按自身大小，就不存在 overflow:hidden 了; 主要是为了内部子元素能通过 100%来得到上级 height 的固定值;

### navigationStyle:custom

小程序中每个页面的 json 配置文件是对当前页面的一些配置，在 app.json 中是总的配置文件，会作用到所有的页面上，之前默认的配置属性里面

## 撩课学院小程序开发 19 年 5 月录制开始 7 月发布

1. 小程序开发介绍
   - css 有增强 wxs（wx-script）
2. 开发前准备工作
   - appid 申请
   - 开发工具:vscode 微信开发者工具
   - 普通编辑默认加载，创建加载选择页模式（下次保存编译启动对应页面）
3. 第一个小程序应用
   - json 格式，对象最后一个 key 的 value 后不可以有 逗号 ，会报错，
   - .js 文件必须有一个 page（{}）对象才可以不然报错
   - 最先加载的是 app.json
4. git 管理项目
   看 git 笔记
5. ### wxml 语法解析
6. mustache 语法细节

- 可写变量 {{name}}
- 表达式 {{'姓名'+name + '年龄'+ age}}
- 三目运算 {{sum > 0 ? sum : 0}}
- class 类名更改` <view class="box {{isActive? 'active':''}}"></view>`

2. ### wxml 条件 wx-if wx-elif wx-else

- 可以通过控制台中的 appdata 来看 js 中 data 变量的值变化
- hidden 属性 全组件都可以用，true 隐藏 false 显示
  hidden 隐藏时也是渲染的，是把 display 设置为 none
  wx-if 隐藏时不渲染组件，
  如果切换频率快 选择 hidden 频率低选择 wx-if

3. ### 列表渲染 wx-for

- 如果渲染变量必须放在"{{}}"里面 数字{{9}}index 从 0-8 字符串'abcd'
- 和 vue 相比 不用写变量 item 和 index 直接用即可以
  小程序写法`wx-for="Array"`就可以使用 item 和 index
  vue 还得写 `v-for="(item,index) in Array"`才能用 item 和 index
- block 和 vue 的 template 一样 只接收控制属性，不渲染的组件，只是一个标签，起包裹作用
- item 和 index 换名字 wx:for-item="movies" wx:for-index="_index"
  注意变量命名不能用- 能用_ 一般需要变换 item 和 index 名字是在多层遍历时，避免导致混乱而改名 如有一个需要遍历的数组 `Array = [ [11,22,33],[44,55,66],[77,88,99]]

  ```html 这个时候分辨清楚 避免item太多乱套
  <block wx:for="Array" wx:for-item="_innerArr" wx:key=" '_' + index'">
    <block wx:for="_innerArrr"> {{item}} </block>
  </block>
  ```

- `wx:key=""`提升性能

4. ### template 模板

   - ### 定义的模板包裹内容不会被渲染
     必须有 name 如果内容为变量 调用时候需要传 data 值

   ```html
   <template name="detail">
     <view>{{age}}</view>
     <view>{{sex}}</view>
   </template>
   ```

   - ### 模板调用

   ```html
   <template is="detail" data="{age:20,sex:'male'}"></template>
   ```

   - ### import 导入和调用
     引入的是 template 文件
     保存的文件名最好是模板的 name，方便阅读和 is 引入

   ```html
   <import src="/template/detail.wxml"></import>
   <template is="detail"></template>
   ```

   - ### include 导入
     可以将目标文件除了 <template/> <wxs/> 外的整个代码引入，相当于是拷贝到 include 位置

5. ## wxs 作用及语法

- 为什么要有 wxs 语法呢
  因为 mustache 语法只能写表达式，不可以调用 jspage/component 中的函数
  vue 的 filter 功能
  wxs 不能使用 es6 语法 let const 都不行只能 var

  ```js 直接写在页面中方式
     <wxs module="computed">
      var message = {
        name:'zhao'
      }
      function sum (sum1,sum2){
        return sum1+sum2
      }
       module.exports={
            message:message, //不支持es6中 简写
            sum, //这样不行的  sum:sum 才对
       }
     </wxs>
      <view >
         {{computed.message.name}}
         {{computed.sum(10,20)}}
      </view>
  ```

  ```js 引入方式
      <wxs src="../必须相对路径" module="computed" />
         <view >
            {{computed.message.name}}
            {{computed.sum(10,20)}}
         </view>

  ```

8. ### 事件

- 事件的绑定
  bindtap 后来 bind:tap 也可以了 为了方便阅读
- 所有组件都有的事件
  bind:touchstart 按下
  bind:touchmove 移动
  bind:touchend 抬起
  bind:tap 点击
  bind:touchlongpress 长按 默认 350 秒 与 tap 不能同时运行

- 事件的捕获和冒泡

1. bind:tap 冒泡
2. capture-bind:tap 前缀是捕获
3. catch:tap 阻止冒泡 capture-catch:tap 阻止捕获
   bind 是不阻止 catch 是阻止， 没有 capture 冒泡，有就捕获
4. ###组件间通讯

- 组件外部页面传值给组件，通过注册属性，属性可以是数据，也可是函数
  组件内部 js 中通过 properties 接收，好比 vue 中的 props 属性，接收属性简写为`list:Array` 对象形式可设置默认值和 observer 属性
- 组件内部事件由自己的 methods 接收，不能写外面，事件里可通过 this.triggerEvent
  函数来触发外部事件

```js
  this.triggerEvent({
    'outerEventName',// 外部注册事件名称  bind:outerEventName
    { name: this.name} // 外部事件函数ditail对象 可以把内部的赋给他
    {} //这个属性是事件是否冒泡，穿越,捕获 默认false都不，bubbles：boolean
  })
```

- 父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法
- 外部传递样式给组件 2.9.2 开始 组件通过~来使用外部样式
  比如在外部页面定义了 `.red{color}` 组件内部直接在标签上 用~就可以引入外部页面样式了， ` <view class="~red"/>` 应用了外部 class 样式 red
  如果是内部组件引用外部组件，用^ a 组件~外部的页面的 class 中的 red，a 组件中的 b 组件可以用^来引入 a 组件中的 red

## 初始化云端的时候，不写 env 会默认第一个创建的环境，注意 建议还是写吧。官方的注释有写

## 云函数本地调试时候，提示没有安装 node module，需要在云函数文件夹下进行 npm install

回忆一下 -D(--save --devDependencies)去 devDependencies
-S(--save)去 dependencies
-P(--production)应该去 proDependencies 忘了 猜的

## wx.navigateTo()

此函数可以跳转页面同时传递数据和事件

```js
wx.navigateTo({
  url: "/pages/.../...",
  events: {
    //添加事件 可以在被打开的页面触发并传值，在被打开页面通过this.getEventChannel().emit('test1',data)
    // 也可以作为传递数据用(需要成功回调中自己触发,res.eventChannel.emit(test1,data))
    //自行回调触发后，在被打开页面的onload时，通过this.getEventChannel().on('test1',function(data){
    //console.log(data) 这种用法作为传递data对象给新打开页
    //})
    test1(data) {
      console.log(data);
    },
  },
  success(res) {
    res.eventChannel.emit("test1", { data: "参数对象" });
  },
});
```

## 小程序属性传值 子原始接收属性不支持 ’-‘ 如果父要用 - 子需要转 小驼峰 子元素赋值变量同接收属性名 \_下划线不受影响，建议使用

```text
      父传值  z-index  子元素接收属性  zIndex  赋值 zIndex
      父传值  z_index  子元素接收属性  z_index 赋值 z_index  建议使用

```

## text 组件的坑

text 内部认换行符 \n 有这个会换行，所以 <text>直接写内容</text>
text 属性 space 是对元素内部空格的解析 值是字符串 'nbsp'根据字体大小,'emsp'中文字符空格,'ensp'中文字符空格的一半,不写这个行间属性会把多个空格变为一个 nbsp;
decode 属性 是解析实体字符 &nbsp; &lt; &gt; &amp; &apos; &ensp; &emsp;

## opacity 和 rgba

opacity 的透明度是只元素，当父元素有这个属性了，那么内部的子元素一样会透明
rgba 是只背景或图片的透明度，当然他只会影响自己，不会影响子元素的
在做 mask 遮罩层的时候，父级应该使用 rgba 这样 子元素不会受父元素影响而透明

## 小程序原生 input 组件的触发规则

1. 当绑定的 bind:foucs 事件触发时，会键盘会弹出，光标可以输入。
2. 属性 fouces 为 true,会自动焦点，就是自动出现光标
3. foucs 即会调出键盘，键盘取消，或确定都会引起**\*\*\***blur 事件触发**\*\*\***
4. 属性 confirm-hold 会在点击键盘右下角时，foucs 保持
5. 属性 hold-keyboard 会在 foucs 情况下点击其他页面区域，保持键盘存在
6. 取消光标会触发 blur 事件,默认可以通过点击页面其他部分(处理 input 区域和键盘) 如果设置了 hold-keyboard 就需要使用 wx.hideKeyboard()来触发键盘消失，键盘消失会导致光标消失，从而触发 blur 事件，
7. 如果设置一个 很多时候可以设置一个取消按钮 来触发 wx.hideKeyboard 事件，从而触发 blur 事件
   那么取消按钮 要调用 wx.hideKeyboard，

## 自定义组件的一些问题

- 自定义组件的盒模型总结

文档中对于自定义组件节点的描述只在这里看到一些，如下图
![虚拟化节点](./虚拟化节点.png)
在没有任何外部 css 属性作用的情况下，这个"普通节点"是一个行盒
![调试器截图](./调试器截图.png)

实际情况下，由于内部外层节点可能是多种盒模型情况，那么这个普通节点的实际效果会是如何呢？(忽然间忘记了行盒父元素包裹块级子元素的效果了，还是我没这么做过？)
下面来测试下这个"普通"节点在内部不同盒模型情况下的实际效果

1. 当内部是文本节点的时候

```html
<!--components/custom-componet.wxml-->
<text>我是文本节点</text>
```

页面效果

![内部文本节点显示效果](./截图1.png)

2. 当内部是块级元素节点时候

```html
<!--components/custom-componet.wxml-->
<view>我是块级元素</view>
```

页面效果

![内部块级元素显示效果](./截图2.png)

3. 当内部是行块盒元素节点时候

```html
<!--components/custom-componet.wxml-->
<view
  style="display:inline-block;
             width:200px;
             height:30px;
             line-height:30px;
             border:1px solid red"
>
  我是行块盒元素
</view>
```

页面效果

![内部行块盒元素显示效果](./截图3.png)

> 小结: 内部不同的盒模型反馈到外部这个自定义组件节点的时候，这个"普通"节点的表现效果基本符合内部元素要实现的效果。这可能是官方把这个普通节点定义为 inline 的初衷吧。
> 但是有些时候，内部节点可能需要一些外部节点的信息来配合自己的效果。比如 width:"50%";height:"30%" 等等...那么这时候要如何写自定义组件呢？

4. 下面测试内部 width 和 height 百分比的情况

先把外部 page 和页面外层元素的 height 设置为 100%;

再设置自定义组件内部元素如下

```html
<!--components/custom-componet.wxml-->
<view
  style="width:70%;
         height:30%;
         text-align:center;
         color:red;"
>
  我是块盒，我的宽高随父级改变
</view>
```

内部节点页面效果

![内部节点效果显示效果](./截图4.png)

自定义节点页面效果

![自定义节点页面效果](./截图5.png)

我们把自定义组件的父级组件 宽度和高度设置改变

```html
<!--index.wxml-->
<view style="width:200px;height:300px;">
  <custom-component />
</view>
```

内部节点页面效果

![内部节点效果显示效果](./截图6.png)

自定义节点页面效果

![自定义节点页面效果](./截图7.png)

> 小结 不改变自定义组件 inline 模型的情况下,内部节点的 width 和 height 百分比是对应的自定义组件节点的父级节点。自定义组件的宽高来自内部元素大小(小程序没有 margin 的视图效果(就是你看感觉不到 margin),但是认 margin 效果真实存在,有时候不小心反应不过来会怀疑人生,这里的内部元素因为是块盒会有自动 margin 撑满)

之所以写这些废话，就是在写自定义组件的时候，为了考虑多种情况(比如组件可能作为块盒使用也可能作为行盒还可能是定位元素等等),此时这个官方所谓的"普通"节点会使我蒙逼，可能是我道行不深吧。看到官方也给出了通过虚拟节点把这个节点干掉的方案，但是也暴漏了更多问题(比如https://developers.weixin.qq.com/community/develop/doc/0006c44dcb47604d0e8b6147051400)。慢慢总结吧。这里只做个提醒、抛砖引玉，受益的小伙伴给点个赞，没人点赞都不爱写总结了！！

```html
<!-- /components/test/index.wxml -->
<view>你好，我的高度继承外部高度</view>
```

```html
<!-- 页面index.html -->
<view>
  <test class="padding-20" style="height:200px" />
</view>
```

上面代码在实际渲染的时候，组件内部的 <view>你好，我的高度继承外部高度</view> 并不能继承到 test 组件节点上的 高度，因为 test 是行盒，padding-20 显示效果也不对，因为是行盒。
解决办法是在 wxss 里面加上 test{display:block}或者在 test 组件加一个外部 container view 在他上面写样式，因为他是块盒，内部的 view 就可以继承到 container 的 width 和 height，padding 样式也符合预期
但是这 2 种办法写起来都不得劲，于是在 2.11.2 基础库版本出现了虚拟化组件节点。

虚拟化节点把自定义组件这个"普通"节点忽略掉，好比把内部的所有节点放到自定义组件的节点位置、可以在其上面写 class 和 style。如果内部是多个根节点 需要注意 外部的 flex 会影响所有根节点。

```js
  Component({
    externalClass:['class','aaaClass'] //这里设置的接受的外部属性，把属性值写在自身的class里面  加入自定义节点是这样写的，<test  class="padding-20" aaaClass="flex" /> 那么内部节点就可以通过 class来选取要获得的样式，这样写 <view class="class aaaClass" />实际上就和properties一回事，就是去掉了{{}}和不在properties里面写class了，而style只能通过properties里面来写了 内部可以这样引用 <view style:{{style}}> 不明白看[文档](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)
    options:{
       virtualHost: true
       addGlobalData:true
    }
     properties: {
          style: String
    }
  })

```

## 小程序的生命周期

1.  app.js 的
    onLaunch

          onShow
                    (component,utils,assets...)
                    加载所有文件注册所有页面
                                         route到index.js(json第一个页面)
                                                                        页面中第一个组件
                                                                        组件 created attached
                                                                        (如果组件还有组件)
                                                                                            组件中的第一个组件created attached
                                                                                            组件中的第二个组件
                                                                                            created attached
                                                                                            ......


                                                                         页面中第二个组件
                                                                             created
                                                                             attached
                                                                          ......

                                                        页面的onLoad



                                                                          第一个组件show
                                                                           pageLifetimes:{
                                                                               show(){}
                                                                            }


                                                                                            组件下的第一个组件
                                                                                            pageLifetimes：{
                                                                                              show(){}
                                                                                            }


                                                        页面的onShow


                                                                                            组件下的第一个组件
                                                                                            ready
                                                                                            组件下的第二个组件
                                                                                            ready
                                                                        第一个组件的ready


                                                                        第二个组件的ready
                                                         页面onReady

2.  1） App.js 文件 App.onLaunch -> App.onShow -> 建立 getApp() 在此之前无法获取 getApp()
    2） 加载所有文件，注册所有页面(注意，如果组件的 js 文件中不小心把 component 写成 page，那么也会被注册为页面)
    router 到 index 页
    3） index 页面中的组件 由上到下 有外到内 Component.created , Component.attached
    4） 第一次发送 data 到 view 层并渲染 （Update view with init data）
    5） 页面 onLoad
    6） 组件 从上到下 由外到内 触发 PageLifeTime 的 show
    7） 页面 onShow
    8） 组件 由上到下 由内而外 触发 lifetimes 中的 ready
    9） 页面 onReady

3.  只有 show 和 hide 可以多次触发 页面跳转时候或返回的时候，

4.  跳转到一个新页面的时候，加载
5.  组件中的 attached 同步 setData 不会导致从渲染

## try catch 的应用

云函数 里面 try catch 还是在小程序端 try catch 呢？？？
考虑还是在云函数，一个是云端快，减少客户端计算，本地代码也能少一些 能后端做的事情尽量后端做吧

云函数中，当匹配一些记录不到的时候，会返回错误 为了不让他报错，可以在初始化数据库的时候 设置一个参数，

```js
const db = cloud.database({
  throwOnNotFount: false, // 不抛出没有发现的错误，即当匹配不到数据库记录时候，返回null而不是抛出错误
});

// res 返回的里面的result.data = null 匹配到了是 result.data是一个数组 里面是匹配到的每一个记录或字段
// 当然如果通过doc(_id)来匹配 那么一定是一个值，data是一个对象，如果通过where匹配多个，data是对象，没有数据就为空数组。匹配的是唯一数据就是data[0]  怎么用自己考虑吧
```

但是在一些 api 调用时候

## 关于布局间隔的问题

**由于不同手机小程序上方的状态栏高度和 capsule 间隔不一样，要做到第一个节点和顶部导航栏间隔合适，就要在节点上动态引入间隔**
组件 style="padding-bottom:{{space}}px"
组件 js 中 import { space } from '../../utils/getNavigationBarHeight'
data:{
space,
}
这样达到所有手机 导航栏和第一个节点的间隔好看些，每个后续节点也可以更具这个 space 来做布局，整体效果更好，不用这个做，其实就是第一节点和导航栏间隔不舒服了！

## js 获取 wx.createSelectorQuery() 获取页面节点数据

1. wx.createSelectorQuery()返回一个 selectQuery 选择器对象 对象中默认是 page 对象,当用 select 或者 selectAll 选择节点时，是不会考虑自定义组件节点的，毕竟自定义组件名他不认识，如果想选择自定义组件节点，要通过.in()方法来制定当前 selectQuery 范围为自定义组件内节点，参数是组件节点。好比在一个自定义组件内要查询内部节点信息，要这么写 wx.createSelectorQuery().in(this) 或用
   this.createSelectorQuery()来代替。
   在页面中选择自定义组件内部节点的方法: 先在自定义组件中把 this 通过 getAPP().globalData.xxx = this 再在页面 onLoad 时,把 globalData.xxx 拿到，这样就获取的自定义组件的 this 对象了！

总结，在 page 页面内 选择页面内节点 用 wx.createSelectorQuery() 要获取自定义组件节点信息需要 in.(自定义组件节点) 自定义组件节点获取 可以传值到 globalData 再由页面获取 因为生命周期是由内而外的 2. selectQuery 的方法:
in(instance 对象) 传组件实例对象
select(string 选择器同 css) 返回 noderef 对象
selectAll(同上) 返回 noderef 对象
selectViewport() 视口对象
exec() 执行 selectQuery 中的队列函数

3. noderef 对象中的方法
   boundingClientRect(function callback) getBoundingClientRect
   看文档吧，差不多就这个意思了！

## 关于 场景重启策略

1. 在 windows 里面设置 strategy 策略
   ` { "restartStrategy": "homePageAndLatestPage"}` homePage
2. 在页面设置

```js
       pages{
        onLoad:function(){
             var prevExitState = this.exitState // 尝试获得上一次退出前 onSaveExitState 保存的数据
             if (prevExitState !== undefined) { // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到
             console.log(prevExitState.myDataField ) //结果  "myData"
             }
        },
        onSaveExitState: function() {
       var exitState = { myDataField: 'myData' } // 需要保存的数据
       return {
         data: exitState,
         expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻
             }
       }
       }

```

3. 1 和 2 设置后, 当从 A 场景进入时候 如果设置的 expireTimeStamp 过期了(不设置默认+1 天)，那么相当于走 homePage 策略 即进入小程序 index 首页
   从 B 场景进入特定页面 ？？？？？

4. 利用 onSaveExitState 更新数据库 UserDetail 取代之前用 onHide 或 onAppHide

在 app.js 中

```js
        pages{
         onLoad:function(){

         },
         onSaveExitState: function() {
           //只有登录客户才会有userDetail,临时用户只有tempCart
    if (this.globalData.isLogin) {
      //登录过了,云端有客户数据了才更新
      wx.cloud.callFunction({
        name: "updateUserDetail",
        data: {
          userDetail: store.userDetail
        }
      }).then(console.log)
      //本地缓存
      console.log(1111111)
      setStorageSync('userDetail', store.userDetail)
    } else {
      setStorageSync('tempCart', store.userDetail.cart)
    }
   }

```

## form 表单

bind:reset catch:submit 绑定后 form 表单内的 button 组件中有 formType = "submit"触发点击时候 会触发 form 表单 submit 绑定的函数 formType="reset" 点击时候会触发 form 表单里面的 reset 时间绑定的函数 会把表单内 value 变为空

```html
<form catchsubmit="confirm" bind:reset="resetHandle">
  <input name="text" value="你好" />
  <input name="password" value="123456" />
  <button formType="submit">submit提交</button>
  <button formType="reeset">reset复位</button>
</form>
```

```js
pages({
  confirm(e) {
    console.log(e.detail.value); // {text: 你好,password:123456}
  },
});
```

## npm 查看版本 等

1. `node -v`
2. `npm -v`
3. 远程服务器 包版本 `npm view [packageName] version` 查看服务器上 vue 的版本
4. 查看本地 包版本 `npm ls [packageName] ` 当前目录 加-g 全局目录
5. 安装及卸载命令

安装模块:npm install [packageName]
安装模块的指定版本:npm install [packageName]@xxx.xx
全局安装模块:npm install [packageName] -g

安装好后写入 package.json 的 dependencies 中（生产环境依赖）:
npm install [packageName] --save 相当于-S

安装好后写入 package.json 的 devDepencies 中（开发环境依赖）:
npm install [packageName] --save-dev 相当于-D

package.json 文件中的 dependencies 字段指定了项目运行所依赖的模块，package.json 文件中的 devDependencies 指定项目开发所需要的模块。
它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。
{
"devDependencies": {
"browserify": "~13.0.0",
"karma-browserify": "~5.0.1"
}
}

npm uninstall [packageName] // 删除模块
npm uninstall [packageName] -g //卸载全局模块
npm uninstall [packageName] --save // 删除模块，同时删除模块留在 package.json 中 dependencies 下的对应信息
npm uninstall [packageName] --save-dev // 删除模块，同时删除模块留在 package.json 中 devDependencies 下的对应信息

作者：凌雲木
链接：https://www.jianshu.com/p/fca8274bd8cc
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 小程序短信验证注册手机号逻辑

1. 安装依赖 `npm i qcloudsms_js ` 加-g 表示全局安装
2.

## 关于小程序 缓存的总结

1. 下载文件 单文件小于 50m

```js
    const res = await wx.cloud.downloadFile({
      fileID:'云文件 ID'
      config:{ //非必须
        env:'云环境ID'
      }
    })
    const tempFilePath = res.tempFilePath//下载的临时文件路径
```

2. 获取临时文件信息

```js
const tempFileInfo = await wx.getFileInfo({
  //获取临时文件信息
  filePath: "临时文件路径", //必须
  digestAlgorithm: "md5", //默认md5 非必须 可选'sha1'
});
console.log(res.size); //临时文件的大小
console.log(res.digest); //临时文件的MD5信息或sha1信息
```

3. 储存文件到本地(pc 端不可用) 合计大小小于 10M

```js
const res = await wx.saveFile({
  tempFilePath: "文件路径",
});
console.log(res.savedFilePath);
//注意：saveFile 会把临时文件移动，因此调用成功后的 tempFilePath 将再不可用
```

4. 保存文件系统的文件到用户磁盘，仅在 PC 端支持

```js
const res = await wx.saveFileToDisk({
  filePath: "文件路径",
});
console.log(res);
```

5. 获取已保存的文件路径列表

```js
const fileListArr = (await wx.getSavedFileList()).fileList;
```

6. 获取已保存的文件信息(不是临时文件)

```js
const res = await wx.getSavedFileInfo({
  //获取已保存文件信息
  filePath: "以保存文件的路径", //必须
});
console.log(res.size);
console.log(res.createTime);
```

7. 云存储缓存 10 分钟 下载临时文件共计最大 10M

## DarkMode 夜间模式

1. 开启方法
   app.json 中 "darkmode" : true

## 关于 scroll-view 中的一些问题

    在商品展示时，常常通过scroll-view来做滚动处理，左面是展示总类，右边展示单个商品
    问题是加入scroll-view的高度是800rpx 左面类别是10项目 右边商品是5个，如果用左右每个项目的高度用固定的rpx来平均分父级高度，在iphone6下看正常，但是在真机测试中，由于rpx转换不同手机型号px过程中误差，导致会有缝隙的出现，于是按下面方法做

1.  用百分比来做，每一子项的高度用百分比来做，比如 10 项没项高度就 10%；5 项每项高度就 20%；
2.  问题来了，虽然平局分了，但是却不知道真实高度，里面的 image 元素如果想要用外面的高度，还需要通过 wx.createSelectorQuery 来做，费事死了，简单方法是通过 image 组件的 mode 的 heightFIx 模式来自动调整他的宽度，通常还需要给他一个默认的 min-width 来防止图片没有加载下来的时候界面过于难看 使用组件的时候 可以更加判断传递一个 min-width 值，虽然默认有，但是不一定合适
3.  但是还有问题是，如果想实现右边滑动的时候哦，左面的总类条需要滚动到适合的位置的话，需要知道右边滚动了几个条目高度，通过 bindScroll 得到的是 px 值，然后乘以百分比来实现高度，这样有了高度，，如果想固定 image 的大小，image 的宽度也可以赋值上去了，这样在图片未加载下来的时候看到的效果比较好，不会出现宽高不一样的背景图片效果。

## image 元素的 mode

1. aspectFix
   图片会按给定的(即 image 的宽高比例)比例来填充 保证长边显示,一个方向会留白
   这种模式必须给定 image 元素 固定的宽高。有 0 就看不到图片了
2. aspectFill
   图片会按给定的(即 image 的宽高比例)比例来填充 保证短边显示,一个方向会被截取
   这种模式必须给定 image 元素 固定的宽高。有 0 就看不到图片了
3. widthFix
   图片的宽度缩放为 image 的宽度,系统会自动给 image 元素一个 height，让 image 高度等于图片按 width 缩放比例得到的值
   这种模式 高度自动 给定宽度即可。 例如 width:'100%'

## 开发者工具配置

1. 设置资源管理区目录字体大小
   D:\Program Files\微信 web 开发者工具\code\package.nw\js\libs\vseditor\static\style.bundled.css 中的.monaco-workbench .part>.content 默认 13 喜欢 18
2. 颜色主题
   Ctrl + shift + Alt + P 打开命令面板 找到颜色主题(color theme) 设置为 dark+
3. 打开设置
   右键目录区-->打开文件夹设置

## 出现改变代码需要 2 次编译的情况，在设置里面把 '使用新版文件监听模块取消勾选'

## 自定义组件路径规则

1. 什么都不写，先找构建的 npm 中有没有这个路径，有用，没有就是当前路径下
2. 写/ 代表根目录，即 project.json 中的 miniprogramRoot 路径,一般是 miniprogram/
3. 可以写../../../相对路径，
4. 当出错时候，先清楚编译结果，再试验，对 TS 支持，哎~~~

## 更改开发者工具 Snippet 片段,ts 部分可以修改 snippets.ts.json

D:\Program Files (x86)\Tencent\微信web开发者工具\code\package.nw\js\libs\vseditor\extensions\wx-snippets\snippets\snippets.ts.json
## 更改 vscode Snippet 片段 



## swiper 组件的默认高度是 150px 会导致当 swiper-item 内容区域大于 150px 时候有无法显示的内容。要注意

## 组件 sticky 时要注意，不是 block 的会失效

## cms 导出的为 json 数据，会是一个一个的对象，中间无逗号，编辑器会报错，但是不影响导入，每个对象中最后一个字段不要加逗号结束，导入会报错！

## 云函数调用，返回的数据大小限制为 1m 超过会报错

## 云开发中的 env: cloud.DYNAMIC_CURRENT_ENV 动态的环境 调用 api 的可以传进去，如果不传就时默认小程序端 cloud.init 传入的 env

## 云函数上传时候，不能由引入的外部模块，会报错找不到的 因为云函数运行环境和当前开发环境不一样，要打包后再上传。

## watch 是由 computed 的插件引入的，只由当监控数据真实改变才会触发，而自带的 observers 是要数据更改，不管和之前是否一样就会触发，更加情况使用 例如数据 data 原来是{name:'zhao'} 给数据 data 重新赋值为{name:"zhao"},如果用 watch 监控 data 则 watch 不会被触发，用 observers 会触发的。

## sourceMap

1. 开启 tsconfig.json 中配置 sourceMap:true
2. 在 project.config 中相关配置"uploadWithSourceMap": true,代表上传代码时候带不带 sourceMap 带的话容易调试，但暴漏源代码
3. 什么时候开启,如果调试定位不到的时候，尝试开启试试
4. 文档相关 ![](https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html)
5. 课程 袁进 webpack devtool 配置课

## debugger 调试

1. 调试台 的 source 中 如果选中右上角的暂停图标，表示在出现控制台报错的时候，自动进入 debugger 状态。
   'pause on exception' 当异常时暂停

## 云函数本地调试 需要在基础库 2.14.1 中

## this.animate 需要在 2.14.1 以上

## 类中的 observable 运行在 static 后面,所以单例类中 static 的 instance = new User() 时，没有 observable 到属性，导致无法 reaction。

## 小程序打包过程，先看首页 json，递归 usingComponents 组件。首页完毕后，按创建事件顺序加载其他未使用组件

## SetupVPN - Lifetime Free VPN

## 指定 npm 打包位置和原 package.json [官方](https://developers.weixin.qq.com/miniprogram/dev/devtools/npm.html)

```json
"setting": {
  "packNpmManually": true, //开启自定义
  "packNpmRelationList": [ //
    {
      "packageJsonPath": "./src_node_modules_1/package.json",//package.json位置,
      "miniprogramNpmDistDir": "./miniprogram/" //要放到哪里
    },
    {
      "packageJsonPath": "./src_node_modules_2/package.json",
      "miniprogramNpmDistDir": "./miniprogram/sub_package"
    }
  ]
}
```
## 小程序生命周期详解

[生命周期图片](生命周期.png)


## npm构建规则总结 时下版本 2.23.4 

1. 会找project.config.json 的 miniprogramRoot字段配置下目录 生成npm_modemodules在同级目录下。
  没有配置就时默认的根目录(同project.config.json所在目录下找)
2. 手动指定
```json setting字段切记 
        "packNpmManually": true, 开启自定义构建
        "packNpmRelationList": [
            {
                "packageJsonPath": "./package.json", //指定要打包的未知
                "miniprogramNpmDistDir": "./miniprogram/"
            }
        ],
```
